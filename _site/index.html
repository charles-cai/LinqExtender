<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  	<title>LinqExtender- A toolkit for building custom providers</title>
  	<link rel="stylesheet" href="style.css" type="text/css" />
	<link rel="stylesheet" title="Idea" href="highlight/styles/idea.css">
</head>
 
<script src="highlight/highlight.pack.js"></script>
 
<body>
   
	<header> 
		<img src="images/linqExtender.jpg" alt="LinqExtender">
		<br/>
	</header>
	
	<section class="headerText">
		LinqExtender is a toolkit for building custom LINQ providers. It provides an abstracted layer over the original IQyeryable and IQueryProvider implementation and provides a simplified syntax tree. Moreover, it covers things like projection , method calls , ordery by , member parsing, etc internally. Therefore developer can focus more on his main task minus the complexity. 









	</section>

	
	<section class="links">
		<p><a href='https://github.com/downloads/mehfuzh/LinqExtender/LinqExtender-3.0.1.zip'>LinqExtender-3.0.1.zip</a> | <a href='https://github.com/mehfuzh/LinqExtender'>Source</a></p>
	</section>


	<section class="content">

	

		<h3>Gettting Started</h3>

	<h3 id='a_simple_text_provider_using_linqextender'>A simple Text provider using LinqExtender.</h3>

<p>The goal of this post is to get started creating custom LINQ (Language Integrated Query) provider using LinqExtender.</p>

<p>To begin, let&#8217;s say i want to build a text provider that prints the TSQL representation of the LINQ query to the screen. Thus, i will create a context class and first implement the following interface from LinqExtender namespace:</p>

<pre><code>public interface IQueryContext&lt;T&gt;
{
  IEnumerable&lt;T&gt; Execute(Ast.Expression expression);  
}</code></pre>

<p>The interface has only one method named <code>Execute</code> that accepts translated expression that is poplulated by the extender and which will be visited to produce the desired TSQL statement.</p>

<p>Generally, the expression will be traversed by visitor pattern, one can write the vistor class specific to LinqExtender then include it as an base class and override its various methods to build the expected meta that will be run against a data store or send over HTTP to produce the expected result or even in my case build a simple TSQL.</p>

<p>To smooth things up, a similar class is provided in LinqExtender.Tests project which i will start as a reference.</p>

<p>Before doing a deep dive. Let me do an short introduction on how the simiplied tree is constructed.</p>

<p>Let&#8217;s consider the following LINQ query:</p>

<pre><code>var query = from book in context
			where book.Id  = 1
			select book</code></pre>

<p>This is translated into :</p>

<pre><code>BlockExpression
	TypeExpression - Contains various reflected accessors for target object.
	LambdaExpression - Represents the where clause.
		BinaryExpression
			MemberExpression - Contains member related to method and accessors
			LiteralEpxression - Contains the evaluted value.</code></pre>

<p>Moving forward to a bit more complex query:</p>

<pre><code>var query = from book in context
	where (book.Id &gt; 1) &amp;&amp; (book.Author == &quot;Scott&quot; || book.Author == &quot;John&quot;)
	Select book</code></pre>

<p>It is translated to:</p>

<pre><code>BlockExpression
	TypeExpression : Name == &quot;Book&quot;, If NameAttribute applied then Name = &quot;as specified&quot;.
	LambdaExpression
		LogicalExpresion - Contains the logical parts | Operator = LogicalOperator.AND
			BinaryExpression 
				MemberExpression 
					Name == &quot;Id&quot;
				LiteralExpression
					Value = 1	
			BinaryExpression
				LogicalExpression : Operator = LogicalOperator.OR
					BinaryExpression
						MemberExpression - 
							Name == &quot;Author&quot;
						LiteralExpression
							Value = &quot;Scott&quot;	
					BinaryExpression
						MemberExpression - 
							Name == &quot;Author&quot;
						LiteralExpression
							Value = &quot;John&quot;	</code></pre>

<p>Here , BinaryExpression or LambdaExpression is LinqExtender&#8217;s version and thus all the expression contains various accessors and methods that easily let you get query information.</p>

<p>Moving forward, Lets add orderby to our first query:</p>

<pre><code>var query = from book in context
			where book.Id  = 1
			orderby book.Author asc
			select book</code></pre>

<p>This will be translated to:</p>

<pre><code>BlockExpression
	TypeExpression
	LambdaExpression
		BinaryExpression
			MemberExpression
			LiteralEpxression
	OrderByExpression</code></pre>

<p>If you write the above query in the following way:</p>

<pre><code>var query = from book in context
			where book.Id  = 1
			orderby book.Author asc
			select new { book.Id, book.Author };</code></pre>

<p>It will also produce the same tree as the previous one. Therefore, it turns out that projection is taken care of internally.</p>

<p>In my sample Text provider, output will be stored in a StringBuilder and can be then printed out to Console.</p>

<pre><code>var builder = new StringBuilder();
var context = new TextContext&lt;Book&gt;(new StringWriter(builder));

var query = from book in context
		    where book.Id == 10 
		    || (book.Id == 1 &amp;&amp; book.Author == &quot;Charlie&quot;)
		    select book;

query.Count();

Console.WriteLine(builder.ToString());				</code></pre>

<p>Now, inside the <code>IQueryContext&lt;T&gt;.Execute(Ast.Expression)</code>, i wrote it like:</p>

<pre><code>public IEnumerable&lt;T&gt; Execute(Ast.Expression expression)
{
	this.Visit(expression);
	return new List&lt;T&gt;().AsEnumerable();
}</code></pre>

<p>Since here result is not important, therefore returned a new instance of <code>List&lt;T&gt;</code> and <code>this.Visit(expression)</code> will eventually branch to various overrides from <code>ExpressionVisitor</code> that I have included in TextContext class; once it has reached the end, the builder will contain a nice formatted TSQL.</p>

<p>Roughly the ExpresisonVisitor.Visit(Ast.Expresion) looks like:</p>

<pre><code>internal Ast.Expression Visit(Ast.Expression expression)
{
	switch (expression.CodeType)
	{
	    case CodeType.BlockExpression:
	        return VisitBlockExpression((Ast.BlockExpression)expression);
	    case CodeType.TypeExpression:
	        return VisitTypeExpression((Ast.TypeExpression)expression);
	    case CodeType.LambdaExpresion:
	        return VisitLambdaExpression((Ast.LambdaExpression)expression);
	    case CodeType.LogicalExpression:
	        return VisitLogicalExpression((Ast.LogicalExpression)expression);
	    case CodeType.BinaryExpression:
	        return VisitBinaryExpression((Ast.BinaryExpression)expression);
	    case CodeType.LiteralExpression:
	        return VisitLiteralExpression((Ast.LiteralExpression)expression);
	    case CodeType.MemberExpression:
	        return VisitMemberExpression((Ast.MemberExpression)expression);
	    case CodeType.OrderbyExpression:
	        return VisitOrderbyExpression((Ast.OrderbyExpression)expression);
	}

	throw new ArgumentException(&quot;Expression type is not supported&quot;);
}</code></pre>

<p>If we follow the translated flow, the first expression that will be of my concern is the TypeExperession where i will be first formating &#8220;Select * From {TypeName}&#8221; string .</p>

<pre><code>public override Ast.Expression VisitTypeExpression(Ast.TypeExpression expression)
{
	writer.Write(string.Format(&quot;select * from {0}&quot;, expression.Type.Name));
	return expression;
}</code></pre>

<p>Now, expression.Type is not System.Type rather its LinqExtender.TypeReference, the Name returns either the original typename or the name that user specifies on top of the class through LinqExtender.NameAttribute, let&#8217;s for example take the following class:</p>

<pre><code>[Name(&quot;flickr.photos.search&quot;)]
public class Photo
{

}</code></pre>

<p>In this case expression.Type.Name == &#8220;flickr.photos.search&#8221;</p>

<p>Considering this part: where book.Id == 10 || (book.Id == 1 &amp;&amp; book.Author == &#8220;Charlie&#8221;)</p>

<p>It will be translated like this</p>

<pre><code>BinaryExpression
LogicalExpression
	BinaryExpression
	BinaryExpression</code></pre>

<p>To print / generate the equivalant TSQL for it , we first of all not need to worry about the order in which the gropings are made or the level of nested groupings are used in the query. While visiting the expression, in any case we only have to generate the meta for the respected expression type. It will be inovoked by extender as it is specified in query during execution.</p>

<p>Therefore, inside VisitLogicalExpression, I wrote :</p>

<pre><code>public override Ast.Expression VisitLogicalExpression(Ast.LogicalExpression expression)
{
	WriteTokenIfReq(expression, Token.LeftParenthesis);
	
	this.Visit(expression.Left);

	WriteLogicalOperator(expression.Operator);

	this.Visit(expression.Right);

	WriteTokenIfReq(expression, Token.RightParentThesis);

	return expression;
}</code></pre>

<p>Here one interesting thing, we may want to include the grouping parenthesis only for nested LogicalExpression. Therefore <code>WriteTokenIfReq</code> is written in this way:</p>

<pre><code>private void WriteTokenIfReq(Ast.LogicalExpression expression, Token token)
{
	if (expression.IsChild)
	{
	    WriteToken(token);
	}
}</code></pre>

<p>Followingly, I override the BinaryExpression:</p>

<pre><code>public override Ast.Expression VisitBinaryExpression(Ast.BinaryExpression expression)
{
	this.Visit(expression.Left);
	writer.Write(GetBinaryOperator(expression.Operator));
	this.Visit(expression.Right);

	return expression;
}</code></pre>

<p>This leads to the Member and Value parsing. In this case, we dont have the control over how user might write his query, he can do:</p>

<pre><code>book.Id == &quot;1&quot;
book.Id == GetId();
...
...
etc</code></pre>

<p>However, we dont have to bother how as in LinqExtender BinaryExpression.Left will either be BinaryExpression or MemberExpression and BinaryExpression.Right will either be BinaryExpression or LiteralExpression. Since, it is internally handled.</p>

<p>In the sample provider, I have overriden <code>VisitMemberExpression</code> to simply print the member name:</p>

<pre><code>public override Ast.Expression VisitMemberExpression(Ast.MemberExpression expression)
{
	writer.Write(expression.FullName);
	return expression;
}</code></pre>

<p>Here to include i am printing the full member name includeing that includes typename (of course the NameAttribute will be applied here as well).</p>

<p>Despite, <code>MemberExpression</code> class contains other accessors and methods that can be useful in more complex scenarios:</p>

<pre><code>MemberEpxression
	Name 
	FullName - Includes the type name
	Member - is LinqExtender.MemberReference
	DeclaringType - is TypeReference
	FindAttribute&lt;T&gt;() - Finds user-defined attribute</code></pre>

<p>Over to getting started, final step is to print value aginst <code>VisitLiteralExpression</code></p>

<pre><code>public override Ast.Expression VisitLiteralExpression(Ast.LiteralExpression expression)
{
	WriteValue(expression.Type, expression.Value);
	return expression;
}</code></pre>

<p>Here, <code>expression.Type</code> referes to the TypeReference of value or member type that is compared.</p>

<p>Once the test code at the begining is run it will print the following output:</p>

<pre><code>select * from Book
where
Book.Id = 10 OR (Book.Id = 1 AND Book.Author = &quot;Charlie&quot;)</code></pre>

<p>This sample provider is included in LinqExtender.Tests project with addtional examples, like how i have to visit <code>OrderByExpression</code>, I leave that for the reader to explore.</p>

<p>The project is a revamp of the original LinqExtender project at <a href='http://linqExtender.codeplex.com'>CodePlex</a>. The source and download is included at the top. Moreover, please feel free to fork, make updates and i will be happy to merge.</p>

<p>Happy Coding!!</p>

	<p class="smallText">Last updated on 28 November 2010 by Mehfuz Hossain</p>

	

	</section>

</body>

<script type="text/javascript">
hljs.tabReplace = '    '; // 4 spaces
hljs.initHighlightingOnLoad();
</script>

</html>
